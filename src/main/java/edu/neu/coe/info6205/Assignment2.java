package edu.neu.coe.info6205;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import edu.neu.coe.info6205.sort.simple.InsertionSort;
import edu.neu.coe.info6205.util.Benchmark_Timer;

public class Assignment2 {
	//Inital value of N
    private static final int INITIAL_VALUE_OF_N = 10;
    
    //Number of values of N, doubling them every time
    private static final int DOUBLING_N_COUNT = 10;
    
    //Number of runs for a given N and array input
    private static final int NUMBER_OF_RUNS = 14;
    
    //Max value in the array
    private static final int MAX_NO_IN_ARRAY = -10000;
    
    //Min value in the array
	private static final int MIN_NO_IN_ARRAY = 10000;

	private static ArrayList<Integer[]> generateAnArray(int n,int MAX_NO_IN_ARRAY,int MIN_NO_IN_ARRAY){
		ArrayList<Integer[]> result = new ArrayList<Integer[]>();
		Integer[] random = new Integer[n];
		for(int i=0;i<n;i++) {
			random[i] = (int) (MIN_NO_IN_ARRAY + ((MAX_NO_IN_ARRAY-MIN_NO_IN_ARRAY)*Math.random()));
		}
		Integer[] unSorted = random.clone();
		Collections.sort(Arrays.asList(unSorted));
		
		Integer[] sorted_reverse = unSorted.clone();
		Collections.reverse(Arrays.asList(sorted_reverse));
		
		//Partially sorted array is generated by sorting the first 70% of the array
		Integer[] sorted_partially = random.clone();
		new InsertionSort<Integer>().sort(sorted_partially,0,(int) (n*0.7));
		
		result.add(random);
		result.add(unSorted);
		result.add(sorted_reverse);
		result.add(sorted_partially);
		
		return result;
	}
	
	private static int getInversions(Integer[] inp) {
		int ans=0;
		for(int i=0;i<inp.length-1;i++) {
			for(int j=i+1;j<inp.length;j++) {
				if(j<i) ans++;
			}
		}
		return ans;
	}

	public static void main(String[] args) {
		
		//pre function creates a clone of the array so the original array is not modified during sort for future runs
    	UnaryOperator<Integer[]> pre = inp -> {return inp.clone();};
    	
    	//function to be benchmarked; sorts array using insertion sort
    	Consumer<Integer[]> func = inp -> new InsertionSort<Integer>().sort(inp,0,inp.length);
    	
    	//post function checks if inversions in result is > 0, and prints an error if so.
    	Consumer<Integer[]> post = inp -> {
    		if (getInversions(inp)>0) System.out.println("OUTPUT NOT SORTED");
    	};
    	
    	Benchmark_Timer<Integer[]> t = new Benchmark_Timer<Integer[]>("Insertion Sort Benchmark",pre,func,post);
    	
    	//run the benchmark for various values of n and different array types. store results in a csv file.
    	try {
			FileWriter writer = new FileWriter("results/insertion_sort/results.csv");
			writer.write("n,Random,Sorted,ReverseSorted,PartiallySorted\n");
			for(int size=INITIAL_VALUE_OF_N;size<=INITIAL_VALUE_OF_N*Math.pow(2, DOUBLING_N_COUNT);size=size*2) {
		    	ArrayList<Integer[]> inputs = generateAnArray(size,MAX_NO_IN_ARRAY,MIN_NO_IN_ARRAY);
		    	writer.write(size+",");
		    	System.out.println("Testing for n: "+size);
		    	writer.write(Double.toString(t.run(inputs.get(0), NUMBER_OF_RUNS))+",");
		    	writer.write(Double.toString(t.run(inputs.get(1), NUMBER_OF_RUNS))+",");
		    	writer.write(Double.toString(t.run(inputs.get(2), NUMBER_OF_RUNS))+",");
		    	writer.write(Double.toString(t.run(inputs.get(3), NUMBER_OF_RUNS))+",");
		    	writer.write('\n');
			}
			writer.close();
			System.out.println("Benchmarking finished. Results in results/insertion_sort");
		} catch (IOException e) {
			e.printStackTrace();
		}
    	
	}

}